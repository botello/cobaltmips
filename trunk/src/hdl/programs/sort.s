-- BUBBLE SORT & SELECTION SORT
--
-- Preconditions on Register file
--   Registers set to their register number
--   ex) $0 = 0, $1 = 1, $2 = 2 ...... $31 = 31 
-- Preconditions on Data Memory
--   None. Any data in the first 5 locations will be sorted by Bubble sort.
--   The next 5 data will be sorted by Selection sort.
--
--
--000 00000020 add $0, $0, $0     -- nop *** INITIALIZATION FOR BUBBLE SORT ***
--004 0080F820 add $31, $4, $0    -- $31 = 4 
--008 00BF1019 mul $2, $5, $31    -- ak = 4 * num_of_items
--00c 00000020 add $0, $0, $0     -- noop
--
--010 00001820 add $3, $0, $0     -- ai = 0 *** BUBBLE SORT STARTS ***
--014 007F2020 add $4, $3, $31    -- aj = ai + 4
--018 0082302A slt $6, $4, $2     -- (aj < ak) ?
--01c 10C0000C beq $6, $0, 12     -- if no, program finishes. goto chcker
--
--020 8C6D0000 lw  $13, 0($3)     -- mi = M(ai)       (LABEL: LOAD)
--024 8C8E0000 lw  $14, 0($4)     -- mj = M(aj)
--028 01CD302A slt $6, $14, $13   -- (mj < mi) ?
--02c 10C00002 beq $6, $0, 2      -- if no, skip swap
-- 
--030 AC6E0000 sw  $14, 0($3)     -- M(ai) = mj // swap
--034 AC8D0000 sw  $13, 0($4)     -- M(aj) = mi // swap
--038 007F1820 add $3, $3, $31    -- ai = ai + 4      (LABEL: SKIP SWAP)
--03c 009F2020 add $4, $4, $31    -- aj = aj + 4
--
--  
--040 0082302A slt $6, $4, $2     -- (aj < ak) ?
--044 10C1FFF6 beq $6, $1, -10    -- if yes, goto LOAD
--048 005F1022 sub $2, $2, $31    -- ak = ak - 4
--04c 08000004 jmp 4              -- goto BEGIN
-- 
--050 00000020 add $0,  $0,  $0    -- nop *** CHECKER FOR FIRST 5 ITEMS *** 
--054 0000D020 add $26, $0,  $0    -- addr1 = 0
--058 035FD820 add $27, $26, $31   -- addr2 = addr1 + 4
--05c 00BFE019 mul $28, $5, $31    -- addr3 = num_of_items * 4
-- 
--060 039AE020 add $28, $28, $26   -- addr3 = addr3 + addr1
--064 8F5D0000 lw  $29, 0 ($26)    -- maddr1 = M(addr1)
--068 8F7E0000 lw  $30, 0 ($27)    -- maddr2 = M(addr2)
--06c 03DDC82A slt $25, $30, $29   -- (maddr2 < maddr1) ?
--
--070 13200001 beq $25, $0,  1     -- if no, proceed to the next data
--074 1000FFFF beq $0,  $0, -1     -- else, You're stuck here
--078 035FD020 add $26, $26, $31   -- addr1 = addr1 + 4
--07c 037FD820 add $27, $27, $31   -- addr2 = addr2 + 4
--
--
--080 137C0001 beq $27, $28, 1     -- if all tested, proceed to the next program
--084 1000FFF7 beq $0,  $0, -9     -- else test next data 
--088 00000020 add $0, $0, $0      -- noop
--08c 00000020 add $0, $0, $0      -- noop
--
--090 00000020 add $0, $0, $0    -- nop *** INITIALIZATION FOR SELECTION SORT ***
--094 00A01020 add $2, $5, $0    -- set min = 5
--098 00BF4820 add $9, $5, $31   -- $9  = 9 
--09c 01215020 add $10, $9, $1   -- $10 = 10
--
--0A0 00003020 add $6, $0, $0    -- slt_result = 0
--0A4 00A01820 add $3, $5, $0    -- i = 5
--0A8 00612020 add $4, $3, $1    -- j = i+1   *** SELECTION SORT STARTS HERE ***
--0Ac 007F6819 mul $13, $3, $31  -- ai = i*4   
--
--0B0 8DB70000 lw  $23, 0($13)   -- mi = M(ai)
--0B4 01A06020 add $12, $13, $0  -- amin = ai
--0B8 02E0B020 add $22, $23, $0  -- mmin = mi
--0Bc 009F7019 mul $14, $4, $31  -- aj  = j*4
--
--
--0C0 8DD80000 lw  $24, 0($14)   -- mj = M(aj)
--0C4 0316302A slt $6, $24, $22  -- (mj < mmin)
--0C8 10C00002 beq $6, $0, 2     -- if(no)
--0Cc 01C06020 add $12, $14, $0  -- amin = aj
--
--0D0 0300B020 add $22, $24, $0  -- mmin = mj
--0D4 00812020 add $4, $4, $1    -- j++
--0D8 108A0001 beq $4, $10, 1    -- (j = 10)
--0Dc 1000FFF7 beq $0, $0, -9    -- if(no)
--
--0E0 00000020 add $0, $0, $0    -- nop
--0E4 ADB60001 sw  $22, 0 ($13)  -- M(ai) = mmin // swap
--0E8 AD970001 sw  $23, 0 ($12)  -- M(amin) = mi // swap
--0Ec 00611820 add $3, $3, $1    -- i++
--
--0F0 00612020 add $4, $3, $1    -- j = i+1
--0F4 10690001 beq $3, $9, 1     -- (i==9)
--0F8 1000FFEC beq $0, $0, -20   -- if(no)
--0Fc 00000020 add $0,  $0,  $0  -- nop 
--
--
--100 00000020 add $0,  $0,  $0    -- *** CHECKER FOR THE NEXT 5 ITEMS *** 
--104 00BFD019 mul $26, $5,  $31   -- addr1 = num_of_items * 4
--108 035FD820 add $27, $26, $31   -- addr2 = addr1 + 4
--10c 00BFE019 mul $28, $5, $31    -- addr3 = num_of_items * 4
-- 
--110 039AE020 add $28, $28, $26   -- addr3 = addr3 + addr1
--114 8F5D0000 lw  $29, 0 ($26)    -- maddr1 = M(addr1)
--118 8F7E0000 lw  $30, 0 ($27)    -- maddr2 = M(addr2)
--11c 03BEC82A slt $25, $29, $30   -- (maddr1 < maddr2) ?
--
--120 13390001 beq $25, $25, 1     -- if yes, proceed to the next data
--124 1000FFFF beq $0,  $0, -1     -- else, You're stuck here
--128 035FD020 add $26, $26, $31   -- addr1 = addr1 + 4
--12c 037FD820 add $27, $27, $31   -- addr2 = addr2 + 4
-- 
--130 137C0001 beq $27, $28, 1     -- if all tested, proceed to the next program
--134 1000FFF7 beq $0,  $0, -9     -- else test next data 
--138 00000020 add $0, $0, $0      -- noop
--13c 00000020 add $0, $0, $0      -- noop
--
--
--REG FILE USED BY BUBBLE SORT
--Initilaly, the content of a register is assumed to be same as its register number.
--
--$0   ----> 0        constant
--$1   ----> 1        constant
--$2   ----> ak       address of k  
--$3   ----> ai       address of i
--$4   ----> aj       address of j
--$5   ----> 5        num_of_items (items at location 0~4 will be sorted)
--$6   ----> result_of_slt 
--$13  ----> mi       M(ai)
--$14  ----> mj       M(aj)
--$25~$30 -> RESERVED for the checker
--$31  ----> 4        conatant for calculating word address
--
--REG FILE USED BY SELECTION SORT
--
--$0   ----> 0       constant
--$1   ----> 1       constant
--$2   ----> min     index of the minimum value
--$3   ----> i       index i
--$4   ----> j       index j
--$5   ----> 5       num_of_items (items at location 5~9 will be sorted)     
--$6   ----> result of slt
--$9   ----> 9       constant
--$10  ----> 10      constant
--$12  ----> amin    address of min
--$13  ----> ai      address of i 
--$14  ----> aj      address of j 
--$15~$21 -> don't care
--$22  ----> mmin    M(amin)
--$23  ----> mi      M(ai)
--$24  ----> mj      M(aj)
--$25~$30 -> RESERVED for checker
--$31  ----> 4       for calculating word address 
--    
--REG FILE USED BY CHECKER
--
--$26  ----> addr1    starting point  
--$27  ----> addr2    ending point
--$28  ----> addr3    bound
--$29  ----> maddr1   M(addr1)
--$30  ----> maddr2   M(addr2)


